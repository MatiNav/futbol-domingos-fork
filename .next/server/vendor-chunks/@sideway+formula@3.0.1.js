"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/@sideway+formula@3.0.1";
exports.ids = ["vendor-chunks/@sideway+formula@3.0.1"];
exports.modules = {

/***/ "(rsc)/./node_modules/.pnpm/@sideway+formula@3.0.1/node_modules/@sideway/formula/lib/index.js":
/*!**********************************************************************************************!*\
  !*** ./node_modules/.pnpm/@sideway+formula@3.0.1/node_modules/@sideway/formula/lib/index.js ***!
  \**********************************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\n\nconst internals = {\n    operators: ['!', '^', '*', '/', '%', '+', '-', '<', '<=', '>', '>=', '==', '!=', '&&', '||', '??'],\n    operatorCharacters: ['!', '^', '*', '/', '%', '+', '-', '<', '=', '>', '&', '|', '?'],\n    operatorsOrder: [['^'], ['*', '/', '%'], ['+', '-'], ['<', '<=', '>', '>='], ['==', '!='], ['&&'], ['||', '??']],\n    operatorsPrefix: ['!', 'n'],\n\n    literals: {\n        '\"': '\"',\n        '`': '`',\n        '\\'': '\\'',\n        '[': ']'\n    },\n\n    numberRx: /^(?:[0-9]*(\\.[0-9]*)?){1}$/,\n    tokenRx: /^[\\w\\$\\#\\.\\@\\:\\{\\}]+$/,\n\n    symbol: Symbol('formula'),\n    settings: Symbol('settings')\n};\n\n\nexports.Parser = class {\n\n    constructor(string, options = {}) {\n\n        if (!options[internals.settings] &&\n            options.constants) {\n\n            for (const constant in options.constants) {\n                const value = options.constants[constant];\n                if (value !== null &&\n                    !['boolean', 'number', 'string'].includes(typeof value)) {\n\n                    throw new Error(`Formula constant ${constant} contains invalid ${typeof value} value type`);\n                }\n            }\n        }\n\n        this.settings = options[internals.settings] ? options : Object.assign({ [internals.settings]: true, constants: {}, functions: {} }, options);\n        this.single = null;\n\n        this._parts = null;\n        this._parse(string);\n    }\n\n    _parse(string) {\n\n        let parts = [];\n        let current = '';\n        let parenthesis = 0;\n        let literal = false;\n\n        const flush = (inner) => {\n\n            if (parenthesis) {\n                throw new Error('Formula missing closing parenthesis');\n            }\n\n            const last = parts.length ? parts[parts.length - 1] : null;\n\n            if (!literal &&\n                !current &&\n                !inner) {\n\n                return;\n            }\n\n            if (last &&\n                last.type === 'reference' &&\n                inner === ')') {                                                                // Function\n\n                last.type = 'function';\n                last.value = this._subFormula(current, last.value);\n                current = '';\n                return;\n            }\n\n            if (inner === ')') {                                                                // Segment\n                const sub = new exports.Parser(current, this.settings);\n                parts.push({ type: 'segment', value: sub });\n            }\n            else if (literal) {\n                if (literal === ']') {                                                          // Reference\n                    parts.push({ type: 'reference', value: current });\n                    current = '';\n                    return;\n                }\n\n                parts.push({ type: 'literal', value: current });                                // Literal\n            }\n            else if (internals.operatorCharacters.includes(current)) {                          // Operator\n                if (last &&\n                    last.type === 'operator' &&\n                    internals.operators.includes(last.value + current)) {                       // 2 characters operator\n\n                    last.value += current;\n                }\n                else {\n                    parts.push({ type: 'operator', value: current });\n                }\n            }\n            else if (current.match(internals.numberRx)) {                                       // Number\n                parts.push({ type: 'constant', value: parseFloat(current) });\n            }\n            else if (this.settings.constants[current] !== undefined) {                          // Constant\n                parts.push({ type: 'constant', value: this.settings.constants[current] });\n            }\n            else {                                                                              // Reference\n                if (!current.match(internals.tokenRx)) {\n                    throw new Error(`Formula contains invalid token: ${current}`);\n                }\n\n                parts.push({ type: 'reference', value: current });\n            }\n\n            current = '';\n        };\n\n        for (const c of string) {\n            if (literal) {\n                if (c === literal) {\n                    flush();\n                    literal = false;\n                }\n                else {\n                    current += c;\n                }\n            }\n            else if (parenthesis) {\n                if (c === '(') {\n                    current += c;\n                    ++parenthesis;\n                }\n                else if (c === ')') {\n                    --parenthesis;\n                    if (!parenthesis) {\n                        flush(c);\n                    }\n                    else {\n                        current += c;\n                    }\n                }\n                else {\n                    current += c;\n                }\n            }\n            else if (c in internals.literals) {\n                literal = internals.literals[c];\n            }\n            else if (c === '(') {\n                flush();\n                ++parenthesis;\n            }\n            else if (internals.operatorCharacters.includes(c)) {\n                flush();\n                current = c;\n                flush();\n            }\n            else if (c !== ' ') {\n                current += c;\n            }\n            else {\n                flush();\n            }\n        }\n\n        flush();\n\n        // Replace prefix - to internal negative operator\n\n        parts = parts.map((part, i) => {\n\n            if (part.type !== 'operator' ||\n                part.value !== '-' ||\n                i && parts[i - 1].type !== 'operator') {\n\n                return part;\n            }\n\n            return { type: 'operator', value: 'n' };\n        });\n\n        // Validate tokens order\n\n        let operator = false;\n        for (const part of parts) {\n            if (part.type === 'operator') {\n                if (internals.operatorsPrefix.includes(part.value)) {\n                    continue;\n                }\n\n                if (!operator) {\n                    throw new Error('Formula contains an operator in invalid position');\n                }\n\n                if (!internals.operators.includes(part.value)) {\n                    throw new Error(`Formula contains an unknown operator ${part.value}`);\n                }\n            }\n            else if (operator) {\n                throw new Error('Formula missing expected operator');\n            }\n\n            operator = !operator;\n        }\n\n        if (!operator) {\n            throw new Error('Formula contains invalid trailing operator');\n        }\n\n        // Identify single part\n\n        if (parts.length === 1 &&\n            ['reference', 'literal', 'constant'].includes(parts[0].type)) {\n\n            this.single = { type: parts[0].type === 'reference' ? 'reference' : 'value', value: parts[0].value };\n        }\n\n        // Process parts\n\n        this._parts = parts.map((part) => {\n\n            // Operators\n\n            if (part.type === 'operator') {\n                return internals.operatorsPrefix.includes(part.value) ? part : part.value;\n            }\n\n            // Literals, constants, segments\n\n            if (part.type !== 'reference') {\n                return part.value;\n            }\n\n            // References\n\n            if (this.settings.tokenRx &&\n                !this.settings.tokenRx.test(part.value)) {\n\n                throw new Error(`Formula contains invalid reference ${part.value}`);\n            }\n\n            if (this.settings.reference) {\n                return this.settings.reference(part.value);\n            }\n\n            return internals.reference(part.value);\n        });\n    }\n\n    _subFormula(string, name) {\n\n        const method = this.settings.functions[name];\n        if (typeof method !== 'function') {\n            throw new Error(`Formula contains unknown function ${name}`);\n        }\n\n        let args = [];\n        if (string) {\n            let current = '';\n            let parenthesis = 0;\n            let literal = false;\n\n            const flush = () => {\n\n                if (!current) {\n                    throw new Error(`Formula contains function ${name} with invalid arguments ${string}`);\n                }\n\n                args.push(current);\n                current = '';\n            };\n\n            for (let i = 0; i < string.length; ++i) {\n                const c = string[i];\n                if (literal) {\n                    current += c;\n                    if (c === literal) {\n                        literal = false;\n                    }\n                }\n                else if (c in internals.literals &&\n                    !parenthesis) {\n\n                    current += c;\n                    literal = internals.literals[c];\n                }\n                else if (c === ',' &&\n                    !parenthesis) {\n\n                    flush();\n                }\n                else {\n                    current += c;\n                    if (c === '(') {\n                        ++parenthesis;\n                    }\n                    else if (c === ')') {\n                        --parenthesis;\n                    }\n                }\n            }\n\n            flush();\n        }\n\n        args = args.map((arg) => new exports.Parser(arg, this.settings));\n\n        return function (context) {\n\n            const innerValues = [];\n            for (const arg of args) {\n                innerValues.push(arg.evaluate(context));\n            }\n\n            return method.call(context, ...innerValues);\n        };\n    }\n\n    evaluate(context) {\n\n        const parts = this._parts.slice();\n\n        // Prefix operators\n\n        for (let i = parts.length - 2; i >= 0; --i) {\n            const part = parts[i];\n            if (part &&\n                part.type === 'operator') {\n\n                const current = parts[i + 1];\n                parts.splice(i + 1, 1);\n                const value = internals.evaluate(current, context);\n                parts[i] = internals.single(part.value, value);\n            }\n        }\n\n        // Left-right operators\n\n        internals.operatorsOrder.forEach((set) => {\n\n            for (let i = 1; i < parts.length - 1;) {\n                if (set.includes(parts[i])) {\n                    const operator = parts[i];\n                    const left = internals.evaluate(parts[i - 1], context);\n                    const right = internals.evaluate(parts[i + 1], context);\n\n                    parts.splice(i, 2);\n                    const result = internals.calculate(operator, left, right);\n                    parts[i - 1] = result === 0 ? 0 : result;                               // Convert -0\n                }\n                else {\n                    i += 2;\n                }\n            }\n        });\n\n        return internals.evaluate(parts[0], context);\n    }\n};\n\n\nexports.Parser.prototype[internals.symbol] = true;\n\n\ninternals.reference = function (name) {\n\n    return function (context) {\n\n        return context && context[name] !== undefined ? context[name] : null;\n    };\n};\n\n\ninternals.evaluate = function (part, context) {\n\n    if (part === null) {\n        return null;\n    }\n\n    if (typeof part === 'function') {\n        return part(context);\n    }\n\n    if (part[internals.symbol]) {\n        return part.evaluate(context);\n    }\n\n    return part;\n};\n\n\ninternals.single = function (operator, value) {\n\n    if (operator === '!') {\n        return value ? false : true;\n    }\n\n    // operator === 'n'\n\n    const negative = -value;\n    if (negative === 0) {       // Override -0\n        return 0;\n    }\n\n    return negative;\n};\n\n\ninternals.calculate = function (operator, left, right) {\n\n    if (operator === '??') {\n        return internals.exists(left) ? left : right;\n    }\n\n    if (typeof left === 'string' ||\n        typeof right === 'string') {\n\n        if (operator === '+') {\n            left = internals.exists(left) ? left : '';\n            right = internals.exists(right) ? right : '';\n            return left + right;\n        }\n    }\n    else {\n        switch (operator) {\n            case '^': return Math.pow(left, right);\n            case '*': return left * right;\n            case '/': return left / right;\n            case '%': return left % right;\n            case '+': return left + right;\n            case '-': return left - right;\n        }\n    }\n\n    switch (operator) {\n        case '<': return left < right;\n        case '<=': return left <= right;\n        case '>': return left > right;\n        case '>=': return left >= right;\n        case '==': return left === right;\n        case '!=': return left !== right;\n        case '&&': return left && right;\n        case '||': return left || right;\n    }\n\n    return null;\n};\n\n\ninternals.exists = function (value) {\n\n    return value !== null && value !== undefined;\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvLnBucG0vQHNpZGV3YXkrZm9ybXVsYUAzLjAuMS9ub2RlX21vZHVsZXMvQHNpZGV3YXkvZm9ybXVsYS9saWIvaW5kZXguanMiLCJtYXBwaW5ncyI6IkFBQWE7O0FBRWI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTCxzQ0FBc0MsRUFBRTtBQUN4Qyw4QkFBOEIsRUFBRTs7QUFFaEM7QUFDQTtBQUNBOzs7QUFHQSxjQUFjOztBQUVkLG9DQUFvQzs7QUFFcEM7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSx3REFBd0QsVUFBVSxtQkFBbUIsY0FBYztBQUNuRztBQUNBO0FBQ0E7O0FBRUEsZ0ZBQWdGLHlDQUF5QyxpQkFBaUI7QUFDMUk7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsZ0dBQWdHOztBQUVoRztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGdHQUFnRztBQUNoRztBQUNBLDZCQUE2Qiw2QkFBNkI7QUFDMUQ7QUFDQTtBQUNBLGdHQUFnRztBQUNoRyxpQ0FBaUMsbUNBQW1DO0FBQ3BFO0FBQ0E7QUFDQTs7QUFFQSw2QkFBNkIsaUNBQWlDLGtDQUFrQztBQUNoRztBQUNBLGdHQUFnRztBQUNoRztBQUNBO0FBQ0EsZ0dBQWdHOztBQUVoRztBQUNBO0FBQ0E7QUFDQSxpQ0FBaUMsa0NBQWtDO0FBQ25FO0FBQ0E7QUFDQSxnR0FBZ0c7QUFDaEcsNkJBQTZCLDhDQUE4QztBQUMzRTtBQUNBLGdHQUFnRztBQUNoRyw2QkFBNkIsMkRBQTJEO0FBQ3hGO0FBQ0EsZ0dBQWdHO0FBQ2hHO0FBQ0EsdUVBQXVFLFFBQVE7QUFDL0U7O0FBRUEsNkJBQTZCLG1DQUFtQztBQUNoRTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEscUJBQXFCO0FBQ3JCLFNBQVM7O0FBRVQ7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDRFQUE0RSxXQUFXO0FBQ3ZGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQSw0QkFBNEI7QUFDNUI7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBLHNFQUFzRSxXQUFXO0FBQ2pGOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFNBQVM7QUFDVDs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsaUVBQWlFLEtBQUs7QUFDdEU7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBLGlFQUFpRSxNQUFNLHlCQUF5QixPQUFPO0FBQ3ZHOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSw0QkFBNEIsbUJBQW1CO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSx1Q0FBdUMsUUFBUTtBQUMvQztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBLDRCQUE0QixxQkFBcUI7QUFDakQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLDRGQUE0RjtBQUM1RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0E7OztBQUdBOzs7QUFHQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7OztBQUdBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7OztBQUdBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBLGdDQUFnQztBQUNoQztBQUNBOztBQUVBO0FBQ0E7OztBQUdBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7OztBQUdBOztBQUVBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9mdXRib2wvLi9ub2RlX21vZHVsZXMvLnBucG0vQHNpZGV3YXkrZm9ybXVsYUAzLjAuMS9ub2RlX21vZHVsZXMvQHNpZGV3YXkvZm9ybXVsYS9saWIvaW5kZXguanM/ZWEyMCJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbmNvbnN0IGludGVybmFscyA9IHtcbiAgICBvcGVyYXRvcnM6IFsnIScsICdeJywgJyonLCAnLycsICclJywgJysnLCAnLScsICc8JywgJzw9JywgJz4nLCAnPj0nLCAnPT0nLCAnIT0nLCAnJiYnLCAnfHwnLCAnPz8nXSxcbiAgICBvcGVyYXRvckNoYXJhY3RlcnM6IFsnIScsICdeJywgJyonLCAnLycsICclJywgJysnLCAnLScsICc8JywgJz0nLCAnPicsICcmJywgJ3wnLCAnPyddLFxuICAgIG9wZXJhdG9yc09yZGVyOiBbWydeJ10sIFsnKicsICcvJywgJyUnXSwgWycrJywgJy0nXSwgWyc8JywgJzw9JywgJz4nLCAnPj0nXSwgWyc9PScsICchPSddLCBbJyYmJ10sIFsnfHwnLCAnPz8nXV0sXG4gICAgb3BlcmF0b3JzUHJlZml4OiBbJyEnLCAnbiddLFxuXG4gICAgbGl0ZXJhbHM6IHtcbiAgICAgICAgJ1wiJzogJ1wiJyxcbiAgICAgICAgJ2AnOiAnYCcsXG4gICAgICAgICdcXCcnOiAnXFwnJyxcbiAgICAgICAgJ1snOiAnXSdcbiAgICB9LFxuXG4gICAgbnVtYmVyUng6IC9eKD86WzAtOV0qKFxcLlswLTldKik/KXsxfSQvLFxuICAgIHRva2VuUng6IC9eW1xcd1xcJFxcI1xcLlxcQFxcOlxce1xcfV0rJC8sXG5cbiAgICBzeW1ib2w6IFN5bWJvbCgnZm9ybXVsYScpLFxuICAgIHNldHRpbmdzOiBTeW1ib2woJ3NldHRpbmdzJylcbn07XG5cblxuZXhwb3J0cy5QYXJzZXIgPSBjbGFzcyB7XG5cbiAgICBjb25zdHJ1Y3RvcihzdHJpbmcsIG9wdGlvbnMgPSB7fSkge1xuXG4gICAgICAgIGlmICghb3B0aW9uc1tpbnRlcm5hbHMuc2V0dGluZ3NdICYmXG4gICAgICAgICAgICBvcHRpb25zLmNvbnN0YW50cykge1xuXG4gICAgICAgICAgICBmb3IgKGNvbnN0IGNvbnN0YW50IGluIG9wdGlvbnMuY29uc3RhbnRzKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgdmFsdWUgPSBvcHRpb25zLmNvbnN0YW50c1tjb25zdGFudF07XG4gICAgICAgICAgICAgICAgaWYgKHZhbHVlICE9PSBudWxsICYmXG4gICAgICAgICAgICAgICAgICAgICFbJ2Jvb2xlYW4nLCAnbnVtYmVyJywgJ3N0cmluZyddLmluY2x1ZGVzKHR5cGVvZiB2YWx1ZSkpIHtcblxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEZvcm11bGEgY29uc3RhbnQgJHtjb25zdGFudH0gY29udGFpbnMgaW52YWxpZCAke3R5cGVvZiB2YWx1ZX0gdmFsdWUgdHlwZWApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuc2V0dGluZ3MgPSBvcHRpb25zW2ludGVybmFscy5zZXR0aW5nc10gPyBvcHRpb25zIDogT2JqZWN0LmFzc2lnbih7IFtpbnRlcm5hbHMuc2V0dGluZ3NdOiB0cnVlLCBjb25zdGFudHM6IHt9LCBmdW5jdGlvbnM6IHt9IH0sIG9wdGlvbnMpO1xuICAgICAgICB0aGlzLnNpbmdsZSA9IG51bGw7XG5cbiAgICAgICAgdGhpcy5fcGFydHMgPSBudWxsO1xuICAgICAgICB0aGlzLl9wYXJzZShzdHJpbmcpO1xuICAgIH1cblxuICAgIF9wYXJzZShzdHJpbmcpIHtcblxuICAgICAgICBsZXQgcGFydHMgPSBbXTtcbiAgICAgICAgbGV0IGN1cnJlbnQgPSAnJztcbiAgICAgICAgbGV0IHBhcmVudGhlc2lzID0gMDtcbiAgICAgICAgbGV0IGxpdGVyYWwgPSBmYWxzZTtcblxuICAgICAgICBjb25zdCBmbHVzaCA9IChpbm5lcikgPT4ge1xuXG4gICAgICAgICAgICBpZiAocGFyZW50aGVzaXMpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0Zvcm11bGEgbWlzc2luZyBjbG9zaW5nIHBhcmVudGhlc2lzJyk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGNvbnN0IGxhc3QgPSBwYXJ0cy5sZW5ndGggPyBwYXJ0c1twYXJ0cy5sZW5ndGggLSAxXSA6IG51bGw7XG5cbiAgICAgICAgICAgIGlmICghbGl0ZXJhbCAmJlxuICAgICAgICAgICAgICAgICFjdXJyZW50ICYmXG4gICAgICAgICAgICAgICAgIWlubmVyKSB7XG5cbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChsYXN0ICYmXG4gICAgICAgICAgICAgICAgbGFzdC50eXBlID09PSAncmVmZXJlbmNlJyAmJlxuICAgICAgICAgICAgICAgIGlubmVyID09PSAnKScpIHsgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gRnVuY3Rpb25cblxuICAgICAgICAgICAgICAgIGxhc3QudHlwZSA9ICdmdW5jdGlvbic7XG4gICAgICAgICAgICAgICAgbGFzdC52YWx1ZSA9IHRoaXMuX3N1YkZvcm11bGEoY3VycmVudCwgbGFzdC52YWx1ZSk7XG4gICAgICAgICAgICAgICAgY3VycmVudCA9ICcnO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKGlubmVyID09PSAnKScpIHsgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gU2VnbWVudFxuICAgICAgICAgICAgICAgIGNvbnN0IHN1YiA9IG5ldyBleHBvcnRzLlBhcnNlcihjdXJyZW50LCB0aGlzLnNldHRpbmdzKTtcbiAgICAgICAgICAgICAgICBwYXJ0cy5wdXNoKHsgdHlwZTogJ3NlZ21lbnQnLCB2YWx1ZTogc3ViIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAobGl0ZXJhbCkge1xuICAgICAgICAgICAgICAgIGlmIChsaXRlcmFsID09PSAnXScpIHsgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gUmVmZXJlbmNlXG4gICAgICAgICAgICAgICAgICAgIHBhcnRzLnB1c2goeyB0eXBlOiAncmVmZXJlbmNlJywgdmFsdWU6IGN1cnJlbnQgfSk7XG4gICAgICAgICAgICAgICAgICAgIGN1cnJlbnQgPSAnJztcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHBhcnRzLnB1c2goeyB0eXBlOiAnbGl0ZXJhbCcsIHZhbHVlOiBjdXJyZW50IH0pOyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gTGl0ZXJhbFxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoaW50ZXJuYWxzLm9wZXJhdG9yQ2hhcmFjdGVycy5pbmNsdWRlcyhjdXJyZW50KSkgeyAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gT3BlcmF0b3JcbiAgICAgICAgICAgICAgICBpZiAobGFzdCAmJlxuICAgICAgICAgICAgICAgICAgICBsYXN0LnR5cGUgPT09ICdvcGVyYXRvcicgJiZcbiAgICAgICAgICAgICAgICAgICAgaW50ZXJuYWxzLm9wZXJhdG9ycy5pbmNsdWRlcyhsYXN0LnZhbHVlICsgY3VycmVudCkpIHsgICAgICAgICAgICAgICAgICAgICAgIC8vIDIgY2hhcmFjdGVycyBvcGVyYXRvclxuXG4gICAgICAgICAgICAgICAgICAgIGxhc3QudmFsdWUgKz0gY3VycmVudDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHBhcnRzLnB1c2goeyB0eXBlOiAnb3BlcmF0b3InLCB2YWx1ZTogY3VycmVudCB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChjdXJyZW50Lm1hdGNoKGludGVybmFscy5udW1iZXJSeCkpIHsgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBOdW1iZXJcbiAgICAgICAgICAgICAgICBwYXJ0cy5wdXNoKHsgdHlwZTogJ2NvbnN0YW50JywgdmFsdWU6IHBhcnNlRmxvYXQoY3VycmVudCkgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICh0aGlzLnNldHRpbmdzLmNvbnN0YW50c1tjdXJyZW50XSAhPT0gdW5kZWZpbmVkKSB7ICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBDb25zdGFudFxuICAgICAgICAgICAgICAgIHBhcnRzLnB1c2goeyB0eXBlOiAnY29uc3RhbnQnLCB2YWx1ZTogdGhpcy5zZXR0aW5ncy5jb25zdGFudHNbY3VycmVudF0gfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHsgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBSZWZlcmVuY2VcbiAgICAgICAgICAgICAgICBpZiAoIWN1cnJlbnQubWF0Y2goaW50ZXJuYWxzLnRva2VuUngpKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgRm9ybXVsYSBjb250YWlucyBpbnZhbGlkIHRva2VuOiAke2N1cnJlbnR9YCk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgcGFydHMucHVzaCh7IHR5cGU6ICdyZWZlcmVuY2UnLCB2YWx1ZTogY3VycmVudCB9KTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgY3VycmVudCA9ICcnO1xuICAgICAgICB9O1xuXG4gICAgICAgIGZvciAoY29uc3QgYyBvZiBzdHJpbmcpIHtcbiAgICAgICAgICAgIGlmIChsaXRlcmFsKSB7XG4gICAgICAgICAgICAgICAgaWYgKGMgPT09IGxpdGVyYWwpIHtcbiAgICAgICAgICAgICAgICAgICAgZmx1c2goKTtcbiAgICAgICAgICAgICAgICAgICAgbGl0ZXJhbCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgY3VycmVudCArPSBjO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHBhcmVudGhlc2lzKSB7XG4gICAgICAgICAgICAgICAgaWYgKGMgPT09ICcoJykge1xuICAgICAgICAgICAgICAgICAgICBjdXJyZW50ICs9IGM7XG4gICAgICAgICAgICAgICAgICAgICsrcGFyZW50aGVzaXM7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKGMgPT09ICcpJykge1xuICAgICAgICAgICAgICAgICAgICAtLXBhcmVudGhlc2lzO1xuICAgICAgICAgICAgICAgICAgICBpZiAoIXBhcmVudGhlc2lzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBmbHVzaChjKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGN1cnJlbnQgKz0gYztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgY3VycmVudCArPSBjO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGMgaW4gaW50ZXJuYWxzLmxpdGVyYWxzKSB7XG4gICAgICAgICAgICAgICAgbGl0ZXJhbCA9IGludGVybmFscy5saXRlcmFsc1tjXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGMgPT09ICcoJykge1xuICAgICAgICAgICAgICAgIGZsdXNoKCk7XG4gICAgICAgICAgICAgICAgKytwYXJlbnRoZXNpcztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGludGVybmFscy5vcGVyYXRvckNoYXJhY3RlcnMuaW5jbHVkZXMoYykpIHtcbiAgICAgICAgICAgICAgICBmbHVzaCgpO1xuICAgICAgICAgICAgICAgIGN1cnJlbnQgPSBjO1xuICAgICAgICAgICAgICAgIGZsdXNoKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChjICE9PSAnICcpIHtcbiAgICAgICAgICAgICAgICBjdXJyZW50ICs9IGM7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBmbHVzaCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgZmx1c2goKTtcblxuICAgICAgICAvLyBSZXBsYWNlIHByZWZpeCAtIHRvIGludGVybmFsIG5lZ2F0aXZlIG9wZXJhdG9yXG5cbiAgICAgICAgcGFydHMgPSBwYXJ0cy5tYXAoKHBhcnQsIGkpID0+IHtcblxuICAgICAgICAgICAgaWYgKHBhcnQudHlwZSAhPT0gJ29wZXJhdG9yJyB8fFxuICAgICAgICAgICAgICAgIHBhcnQudmFsdWUgIT09ICctJyB8fFxuICAgICAgICAgICAgICAgIGkgJiYgcGFydHNbaSAtIDFdLnR5cGUgIT09ICdvcGVyYXRvcicpIHtcblxuICAgICAgICAgICAgICAgIHJldHVybiBwYXJ0O1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4geyB0eXBlOiAnb3BlcmF0b3InLCB2YWx1ZTogJ24nIH07XG4gICAgICAgIH0pO1xuXG4gICAgICAgIC8vIFZhbGlkYXRlIHRva2VucyBvcmRlclxuXG4gICAgICAgIGxldCBvcGVyYXRvciA9IGZhbHNlO1xuICAgICAgICBmb3IgKGNvbnN0IHBhcnQgb2YgcGFydHMpIHtcbiAgICAgICAgICAgIGlmIChwYXJ0LnR5cGUgPT09ICdvcGVyYXRvcicpIHtcbiAgICAgICAgICAgICAgICBpZiAoaW50ZXJuYWxzLm9wZXJhdG9yc1ByZWZpeC5pbmNsdWRlcyhwYXJ0LnZhbHVlKSkge1xuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpZiAoIW9wZXJhdG9yKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignRm9ybXVsYSBjb250YWlucyBhbiBvcGVyYXRvciBpbiBpbnZhbGlkIHBvc2l0aW9uJyk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgaWYgKCFpbnRlcm5hbHMub3BlcmF0b3JzLmluY2x1ZGVzKHBhcnQudmFsdWUpKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgRm9ybXVsYSBjb250YWlucyBhbiB1bmtub3duIG9wZXJhdG9yICR7cGFydC52YWx1ZX1gKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChvcGVyYXRvcikge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignRm9ybXVsYSBtaXNzaW5nIGV4cGVjdGVkIG9wZXJhdG9yJyk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIG9wZXJhdG9yID0gIW9wZXJhdG9yO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCFvcGVyYXRvcikge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdGb3JtdWxhIGNvbnRhaW5zIGludmFsaWQgdHJhaWxpbmcgb3BlcmF0b3InKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIElkZW50aWZ5IHNpbmdsZSBwYXJ0XG5cbiAgICAgICAgaWYgKHBhcnRzLmxlbmd0aCA9PT0gMSAmJlxuICAgICAgICAgICAgWydyZWZlcmVuY2UnLCAnbGl0ZXJhbCcsICdjb25zdGFudCddLmluY2x1ZGVzKHBhcnRzWzBdLnR5cGUpKSB7XG5cbiAgICAgICAgICAgIHRoaXMuc2luZ2xlID0geyB0eXBlOiBwYXJ0c1swXS50eXBlID09PSAncmVmZXJlbmNlJyA/ICdyZWZlcmVuY2UnIDogJ3ZhbHVlJywgdmFsdWU6IHBhcnRzWzBdLnZhbHVlIH07XG4gICAgICAgIH1cblxuICAgICAgICAvLyBQcm9jZXNzIHBhcnRzXG5cbiAgICAgICAgdGhpcy5fcGFydHMgPSBwYXJ0cy5tYXAoKHBhcnQpID0+IHtcblxuICAgICAgICAgICAgLy8gT3BlcmF0b3JzXG5cbiAgICAgICAgICAgIGlmIChwYXJ0LnR5cGUgPT09ICdvcGVyYXRvcicpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gaW50ZXJuYWxzLm9wZXJhdG9yc1ByZWZpeC5pbmNsdWRlcyhwYXJ0LnZhbHVlKSA/IHBhcnQgOiBwYXJ0LnZhbHVlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBMaXRlcmFscywgY29uc3RhbnRzLCBzZWdtZW50c1xuXG4gICAgICAgICAgICBpZiAocGFydC50eXBlICE9PSAncmVmZXJlbmNlJykge1xuICAgICAgICAgICAgICAgIHJldHVybiBwYXJ0LnZhbHVlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBSZWZlcmVuY2VzXG5cbiAgICAgICAgICAgIGlmICh0aGlzLnNldHRpbmdzLnRva2VuUnggJiZcbiAgICAgICAgICAgICAgICAhdGhpcy5zZXR0aW5ncy50b2tlblJ4LnRlc3QocGFydC52YWx1ZSkpIHtcblxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgRm9ybXVsYSBjb250YWlucyBpbnZhbGlkIHJlZmVyZW5jZSAke3BhcnQudmFsdWV9YCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmICh0aGlzLnNldHRpbmdzLnJlZmVyZW5jZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnNldHRpbmdzLnJlZmVyZW5jZShwYXJ0LnZhbHVlKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIGludGVybmFscy5yZWZlcmVuY2UocGFydC52YWx1ZSk7XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIF9zdWJGb3JtdWxhKHN0cmluZywgbmFtZSkge1xuXG4gICAgICAgIGNvbnN0IG1ldGhvZCA9IHRoaXMuc2V0dGluZ3MuZnVuY3Rpb25zW25hbWVdO1xuICAgICAgICBpZiAodHlwZW9mIG1ldGhvZCAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBGb3JtdWxhIGNvbnRhaW5zIHVua25vd24gZnVuY3Rpb24gJHtuYW1lfWApO1xuICAgICAgICB9XG5cbiAgICAgICAgbGV0IGFyZ3MgPSBbXTtcbiAgICAgICAgaWYgKHN0cmluZykge1xuICAgICAgICAgICAgbGV0IGN1cnJlbnQgPSAnJztcbiAgICAgICAgICAgIGxldCBwYXJlbnRoZXNpcyA9IDA7XG4gICAgICAgICAgICBsZXQgbGl0ZXJhbCA9IGZhbHNlO1xuXG4gICAgICAgICAgICBjb25zdCBmbHVzaCA9ICgpID0+IHtcblxuICAgICAgICAgICAgICAgIGlmICghY3VycmVudCkge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEZvcm11bGEgY29udGFpbnMgZnVuY3Rpb24gJHtuYW1lfSB3aXRoIGludmFsaWQgYXJndW1lbnRzICR7c3RyaW5nfWApO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGFyZ3MucHVzaChjdXJyZW50KTtcbiAgICAgICAgICAgICAgICBjdXJyZW50ID0gJyc7XG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHN0cmluZy5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGMgPSBzdHJpbmdbaV07XG4gICAgICAgICAgICAgICAgaWYgKGxpdGVyYWwpIHtcbiAgICAgICAgICAgICAgICAgICAgY3VycmVudCArPSBjO1xuICAgICAgICAgICAgICAgICAgICBpZiAoYyA9PT0gbGl0ZXJhbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbGl0ZXJhbCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKGMgaW4gaW50ZXJuYWxzLmxpdGVyYWxzICYmXG4gICAgICAgICAgICAgICAgICAgICFwYXJlbnRoZXNpcykge1xuXG4gICAgICAgICAgICAgICAgICAgIGN1cnJlbnQgKz0gYztcbiAgICAgICAgICAgICAgICAgICAgbGl0ZXJhbCA9IGludGVybmFscy5saXRlcmFsc1tjXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoYyA9PT0gJywnICYmXG4gICAgICAgICAgICAgICAgICAgICFwYXJlbnRoZXNpcykge1xuXG4gICAgICAgICAgICAgICAgICAgIGZsdXNoKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBjdXJyZW50ICs9IGM7XG4gICAgICAgICAgICAgICAgICAgIGlmIChjID09PSAnKCcpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICsrcGFyZW50aGVzaXM7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoYyA9PT0gJyknKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAtLXBhcmVudGhlc2lzO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBmbHVzaCgpO1xuICAgICAgICB9XG5cbiAgICAgICAgYXJncyA9IGFyZ3MubWFwKChhcmcpID0+IG5ldyBleHBvcnRzLlBhcnNlcihhcmcsIHRoaXMuc2V0dGluZ3MpKTtcblxuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKGNvbnRleHQpIHtcblxuICAgICAgICAgICAgY29uc3QgaW5uZXJWYWx1ZXMgPSBbXTtcbiAgICAgICAgICAgIGZvciAoY29uc3QgYXJnIG9mIGFyZ3MpIHtcbiAgICAgICAgICAgICAgICBpbm5lclZhbHVlcy5wdXNoKGFyZy5ldmFsdWF0ZShjb250ZXh0KSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiBtZXRob2QuY2FsbChjb250ZXh0LCAuLi5pbm5lclZhbHVlcyk7XG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgZXZhbHVhdGUoY29udGV4dCkge1xuXG4gICAgICAgIGNvbnN0IHBhcnRzID0gdGhpcy5fcGFydHMuc2xpY2UoKTtcblxuICAgICAgICAvLyBQcmVmaXggb3BlcmF0b3JzXG5cbiAgICAgICAgZm9yIChsZXQgaSA9IHBhcnRzLmxlbmd0aCAtIDI7IGkgPj0gMDsgLS1pKSB7XG4gICAgICAgICAgICBjb25zdCBwYXJ0ID0gcGFydHNbaV07XG4gICAgICAgICAgICBpZiAocGFydCAmJlxuICAgICAgICAgICAgICAgIHBhcnQudHlwZSA9PT0gJ29wZXJhdG9yJykge1xuXG4gICAgICAgICAgICAgICAgY29uc3QgY3VycmVudCA9IHBhcnRzW2kgKyAxXTtcbiAgICAgICAgICAgICAgICBwYXJ0cy5zcGxpY2UoaSArIDEsIDEpO1xuICAgICAgICAgICAgICAgIGNvbnN0IHZhbHVlID0gaW50ZXJuYWxzLmV2YWx1YXRlKGN1cnJlbnQsIGNvbnRleHQpO1xuICAgICAgICAgICAgICAgIHBhcnRzW2ldID0gaW50ZXJuYWxzLnNpbmdsZShwYXJ0LnZhbHVlLCB2YWx1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvLyBMZWZ0LXJpZ2h0IG9wZXJhdG9yc1xuXG4gICAgICAgIGludGVybmFscy5vcGVyYXRvcnNPcmRlci5mb3JFYWNoKChzZXQpID0+IHtcblxuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDE7IGkgPCBwYXJ0cy5sZW5ndGggLSAxOykge1xuICAgICAgICAgICAgICAgIGlmIChzZXQuaW5jbHVkZXMocGFydHNbaV0pKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IG9wZXJhdG9yID0gcGFydHNbaV07XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGxlZnQgPSBpbnRlcm5hbHMuZXZhbHVhdGUocGFydHNbaSAtIDFdLCBjb250ZXh0KTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgcmlnaHQgPSBpbnRlcm5hbHMuZXZhbHVhdGUocGFydHNbaSArIDFdLCBjb250ZXh0KTtcblxuICAgICAgICAgICAgICAgICAgICBwYXJ0cy5zcGxpY2UoaSwgMik7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IGludGVybmFscy5jYWxjdWxhdGUob3BlcmF0b3IsIGxlZnQsIHJpZ2h0KTtcbiAgICAgICAgICAgICAgICAgICAgcGFydHNbaSAtIDFdID0gcmVzdWx0ID09PSAwID8gMCA6IHJlc3VsdDsgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gQ29udmVydCAtMFxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgaSArPSAyO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG5cbiAgICAgICAgcmV0dXJuIGludGVybmFscy5ldmFsdWF0ZShwYXJ0c1swXSwgY29udGV4dCk7XG4gICAgfVxufTtcblxuXG5leHBvcnRzLlBhcnNlci5wcm90b3R5cGVbaW50ZXJuYWxzLnN5bWJvbF0gPSB0cnVlO1xuXG5cbmludGVybmFscy5yZWZlcmVuY2UgPSBmdW5jdGlvbiAobmFtZSkge1xuXG4gICAgcmV0dXJuIGZ1bmN0aW9uIChjb250ZXh0KSB7XG5cbiAgICAgICAgcmV0dXJuIGNvbnRleHQgJiYgY29udGV4dFtuYW1lXSAhPT0gdW5kZWZpbmVkID8gY29udGV4dFtuYW1lXSA6IG51bGw7XG4gICAgfTtcbn07XG5cblxuaW50ZXJuYWxzLmV2YWx1YXRlID0gZnVuY3Rpb24gKHBhcnQsIGNvbnRleHQpIHtcblxuICAgIGlmIChwYXJ0ID09PSBudWxsKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIGlmICh0eXBlb2YgcGFydCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICByZXR1cm4gcGFydChjb250ZXh0KTtcbiAgICB9XG5cbiAgICBpZiAocGFydFtpbnRlcm5hbHMuc3ltYm9sXSkge1xuICAgICAgICByZXR1cm4gcGFydC5ldmFsdWF0ZShjb250ZXh0KTtcbiAgICB9XG5cbiAgICByZXR1cm4gcGFydDtcbn07XG5cblxuaW50ZXJuYWxzLnNpbmdsZSA9IGZ1bmN0aW9uIChvcGVyYXRvciwgdmFsdWUpIHtcblxuICAgIGlmIChvcGVyYXRvciA9PT0gJyEnKSB7XG4gICAgICAgIHJldHVybiB2YWx1ZSA/IGZhbHNlIDogdHJ1ZTtcbiAgICB9XG5cbiAgICAvLyBvcGVyYXRvciA9PT0gJ24nXG5cbiAgICBjb25zdCBuZWdhdGl2ZSA9IC12YWx1ZTtcbiAgICBpZiAobmVnYXRpdmUgPT09IDApIHsgICAgICAgLy8gT3ZlcnJpZGUgLTBcbiAgICAgICAgcmV0dXJuIDA7XG4gICAgfVxuXG4gICAgcmV0dXJuIG5lZ2F0aXZlO1xufTtcblxuXG5pbnRlcm5hbHMuY2FsY3VsYXRlID0gZnVuY3Rpb24gKG9wZXJhdG9yLCBsZWZ0LCByaWdodCkge1xuXG4gICAgaWYgKG9wZXJhdG9yID09PSAnPz8nKSB7XG4gICAgICAgIHJldHVybiBpbnRlcm5hbHMuZXhpc3RzKGxlZnQpID8gbGVmdCA6IHJpZ2h0O1xuICAgIH1cblxuICAgIGlmICh0eXBlb2YgbGVmdCA9PT0gJ3N0cmluZycgfHxcbiAgICAgICAgdHlwZW9mIHJpZ2h0ID09PSAnc3RyaW5nJykge1xuXG4gICAgICAgIGlmIChvcGVyYXRvciA9PT0gJysnKSB7XG4gICAgICAgICAgICBsZWZ0ID0gaW50ZXJuYWxzLmV4aXN0cyhsZWZ0KSA/IGxlZnQgOiAnJztcbiAgICAgICAgICAgIHJpZ2h0ID0gaW50ZXJuYWxzLmV4aXN0cyhyaWdodCkgPyByaWdodCA6ICcnO1xuICAgICAgICAgICAgcmV0dXJuIGxlZnQgKyByaWdodDtcbiAgICAgICAgfVxuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgc3dpdGNoIChvcGVyYXRvcikge1xuICAgICAgICAgICAgY2FzZSAnXic6IHJldHVybiBNYXRoLnBvdyhsZWZ0LCByaWdodCk7XG4gICAgICAgICAgICBjYXNlICcqJzogcmV0dXJuIGxlZnQgKiByaWdodDtcbiAgICAgICAgICAgIGNhc2UgJy8nOiByZXR1cm4gbGVmdCAvIHJpZ2h0O1xuICAgICAgICAgICAgY2FzZSAnJSc6IHJldHVybiBsZWZ0ICUgcmlnaHQ7XG4gICAgICAgICAgICBjYXNlICcrJzogcmV0dXJuIGxlZnQgKyByaWdodDtcbiAgICAgICAgICAgIGNhc2UgJy0nOiByZXR1cm4gbGVmdCAtIHJpZ2h0O1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgc3dpdGNoIChvcGVyYXRvcikge1xuICAgICAgICBjYXNlICc8JzogcmV0dXJuIGxlZnQgPCByaWdodDtcbiAgICAgICAgY2FzZSAnPD0nOiByZXR1cm4gbGVmdCA8PSByaWdodDtcbiAgICAgICAgY2FzZSAnPic6IHJldHVybiBsZWZ0ID4gcmlnaHQ7XG4gICAgICAgIGNhc2UgJz49JzogcmV0dXJuIGxlZnQgPj0gcmlnaHQ7XG4gICAgICAgIGNhc2UgJz09JzogcmV0dXJuIGxlZnQgPT09IHJpZ2h0O1xuICAgICAgICBjYXNlICchPSc6IHJldHVybiBsZWZ0ICE9PSByaWdodDtcbiAgICAgICAgY2FzZSAnJiYnOiByZXR1cm4gbGVmdCAmJiByaWdodDtcbiAgICAgICAgY2FzZSAnfHwnOiByZXR1cm4gbGVmdCB8fCByaWdodDtcbiAgICB9XG5cbiAgICByZXR1cm4gbnVsbDtcbn07XG5cblxuaW50ZXJuYWxzLmV4aXN0cyA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuXG4gICAgcmV0dXJuIHZhbHVlICE9PSBudWxsICYmIHZhbHVlICE9PSB1bmRlZmluZWQ7XG59O1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/.pnpm/@sideway+formula@3.0.1/node_modules/@sideway/formula/lib/index.js\n");

/***/ })

};
;